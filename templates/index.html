<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini-C Compiler</title>
    <style>
        :root {
            --primary-color: #2563eb;
            --secondary-color: #1e40af;
            --background-dark: #0f172a;
            --surface-dark: #1e293b;
            --surface-light: #334155;
            --text-primary: #f8fafc;
            --text-secondary: #cbd5e1;
            --success-color: #10b981;
            --error-color: #ef4444;
            --warning-color: #f59e0b;
            --border-color: #475569;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--background-dark) 0%, #1a202c 100%);
            color: var(--text-primary);
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            background: var(--surface-dark);
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-color);
        }

        .header h1 {
            font-size: 3rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary-color), #06b6d4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.2rem;
            color: var(--text-secondary);
            max-width: 600px;
            margin: 0 auto;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .editor-section {
            background: var(--surface-dark);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        }

        .section-title {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-icon {
            width: 20px;
            height: 20px;
            fill: var(--primary-color);
        }

        #source-code {
            width: 100%;
            height: 400px;
            background: var(--background-dark);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            color: var(--text-primary);
            resize: vertical;
            line-height: 1.5;
        }

        #source-code:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(37, 99, 235, 0.3);
        }

        .btn-secondary {
            background: var(--surface-light);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
            background: var(--border-color);
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .result-section {
            background: var(--surface-dark);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        }

        .result-content {
            background: var(--background-dark);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            color: var(--text-secondary);
        }

        .token-item {
            display: flex;
            justify-content: space-between;
            padding: 4px 8px;
            margin: 2px 0;
            background: var(--surface-light);
            border-radius: 4px;
            font-size: 12px;
        }

        .token-type {
            color: var(--primary-color);
            font-weight: 600;
        }

        .token-value {
            color: var(--text-secondary);
        }

        .token-line {
            color: var(--warning-color);
            font-size: 11px;
        }

        .error-message {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid var(--error-color);
            color: var(--error-color);
            padding: 12px;
            border-radius: 6px;
            margin: 10px 0;
        }

        .success-message {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid var(--success-color);
            color: var(--success-color);
            padding: 12px;
            border-radius: 6px;
            margin: 10px 0;
        }

        .loading {
            display: none;
            text-align: center;
            color: var(--text-secondary);
        }

        .spinner {
            border: 2px solid var(--surface-light);
            border-top: 2px solid var(--primary-color);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .tab-container {
            margin-bottom: 15px;
        }

        .tab-buttons {
            display: flex;
            border-bottom: 2px solid var(--border-color);
            margin-bottom: 15px;
        }

        .tab-btn {
            padding: 10px 20px;
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            border-bottom: 2px solid transparent;
        }

        .tab-btn.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .symbol-table {
            display: grid;
            gap: 8px;
        }

        .symbol-entry {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            padding: 8px;
            background: var(--surface-light);
            border-radius: 4px;
            font-size: 12px;
        }

        .symbol-name {
            color: var(--primary-color);
            font-weight: 600;
        }

        .symbol-type {
            color: var(--warning-color);
        }

        .symbol-kind {
            color: var(--text-secondary);
        }

        .tac-line {
            padding: 2px 0;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            color: var(--text-secondary);
        }

        .tac-line:hover {
            background: var(--surface-light);
            border-radius: 4px;
            padding-left: 8px;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .container {
                padding: 10px;
            }
            
            #source-code {
                height: 300px;
            }
        }

        /* Syntax highlighting for C code */
        .c-keyword { color: #569cd6; }
        .c-string { color: #ce9178; }
        .c-number { color: #b5cea8; }
        .c-comment { color: #6a9955; font-style: italic; }
        .c-function { color: #dcdcaa; }
        .c-operator { color: #d4d4d4; }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .feature-card {
            background: var(--surface-dark);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            text-align: center;
            transition: transform 0.2s ease;
        }

        .feature-card:hover {
            transform: translateY(-4px);
        }

        .feature-icon {
            width: 48px;
            height: 48px;
            margin: 0 auto 15px;
            fill: var(--primary-color);
        }

        .feature-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .feature-desc {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Mini-C Compiler</h1>
            <p>A comprehensive C compiler implementation with lexical analysis, syntax parsing, and three-address code generation</p>
        </div>

        <div class="feature-grid">
            <div class="feature-card">
                <svg class="feature-icon" viewBox="0 0 24 24">
                    <path d="M12 2L2 7v10c0 5.55 3.84 9.739 9 11 5.16-1.261 9-5.45 9-11V7l-10-5z"/>
                </svg>
                <div class="feature-title">Lexical Analysis</div>
                <div class="feature-desc">Tokenizes C source code with comprehensive token recognition</div>
            </div>
            <div class="feature-card">
                <svg class="feature-icon" viewBox="0 0 24 24">
                    <path d="M4 4h16v2H4V4zm0 4h16v2H4V8zm0 4h11v2H4v-2zm0 4h16v2H4v-2zm17-8l2 2-2 2v-4z"/>
                </svg>
                <div class="feature-title">Syntax Parsing</div>
                <div class="feature-desc">Builds Abstract Syntax Trees with complete grammar support</div>
            </div>
            <div class="feature-card">
                <svg class="feature-icon" viewBox="0 0 24 24">
                    <path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0L19.2 12l-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"/>
                </svg>
                <div class="feature-title">Code Generation</div>
                <div class="feature-desc">Generates three-address code for intermediate representation</div>
            </div>
            <div class="feature-card">
                <svg class="feature-icon" viewBox="0 0 24 24">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                </svg>
                <div class="feature-title">Error Handling</div>
                <div class="feature-desc">Comprehensive error detection and reporting</div>
            </div>
        </div>

        <div class="main-content">
            <div class="editor-section">
                <div class="section-title">
                    <svg class="section-icon" viewBox="0 0 24 24">
                        <path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0L19.2 12l-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"/>
                    </svg>
                    Source Code Editor
                </div>
                <textarea id="source-code" placeholder="Enter your C code here...">int main() {
    int x = 10;
    int y = 20;
    int result = x + y;
    
    if (result > 25) {
        return 1;
    } else {
        return 0;
    }
}</textarea>
                <div class="button-group">
                    <button class="btn btn-primary" onclick="compileCode()">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                        Compile
                    </button>
                    <button class="btn btn-secondary" onclick="clearCode()">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                        </svg>
                        Clear
                    </button>
                    <button class="btn btn-secondary" onclick="loadExample()">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/>
                        </svg>
                        Load Example
                    </button>
                </div>
                <div class="loading" id="loading">
                    <div class="spinner"></div>
                    Compiling...
                </div>
                <div id="messages"></div>
            </div>

            <div class="editor-section">
                <div class="section-title">
                    <svg class="section-icon" viewBox="0 0 24 24">
                        <path d="M12,2A2,2 0 0,1 14,4C14,4.74 13.6,5.39 13,5.73V7H14A7,7 0 0,1 21,14H22A1,1 0 0,1 23,15V18A1,1 0 0,1 22,19H21V20A2,2 0 0,1 19,22H5A2,2 0 0,1 3,20V19H2A1,1 0 0,1 1,18V15A1,1 0 0,1 2,14H3A7,7 0 0,1 10,7H11V5.73C10.4,5.39 10,4.74 10,4A2,2 0 0,1 12,2M7.5,13A2.5,2.5 0 0,0 5,15.5A2.5,2.5 0 0,0 7.5,18A2.5,2.5 0 0,0 10,15.5A2.5,2.5 0 0,0 7.5,13M16.5,13A2.5,2.5 0 0,0 14,15.5A2.5,2.5 0 0,0 16.5,18A2.5,2.5 0 0,0 19,15.5A2.5,2.5 0 0,0 16.5,13Z"/>
                    </svg>
                    Compilation Results
                </div>
                <div class="tab-container">
                    <div class="tab-buttons">
                        <button class="tab-btn active" onclick="switchTab('tokens')">Tokens</button>
                        <button class="tab-btn" onclick="switchTab('ast')">AST</button>
                        <button class="tab-btn" onclick="switchTab('tac')">TAC</button>
                        <button class="tab-btn" onclick="switchTab('symbols')">Symbols</button>
                    </div>
                    
                    <div id="tokens-tab" class="tab-content active">
                        <div id="tokens-result" class="result-content">
                            Tokens will appear here after compilation...
                        </div>
                    </div>
                    
                    <div id="ast-tab" class="tab-content">
                        <div id="ast-result" class="result-content">
                            Abstract Syntax Tree will appear here after compilation...
                        </div>
                    </div>
                    
                    <div id="tac-tab" class="tab-content">
                        <div id="tac-result" class="result-content">
                            Three-Address Code will appear here after compilation...
                        </div>
                    </div>
                    
                    <div id="symbols-tab" class="tab-content">
                        <div id="symbols-result" class="result-content">
                            Symbol table will appear here after compilation...
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Simulated compiler implementation for demo
        class MiniCCompiler {
            constructor() {
                this.tokens = [
                    'INT', 'FLOAT', 'CHAR', 'VOID',
                    'IF', 'ELSE', 'WHILE', 'FOR', 'RETURN',
                    'ID', 'NUMBER', 'STRING',
                    'PLUS', 'MINUS', 'TIMES', 'DIVIDE', 'MODULO',
                    'ASSIGN', 'EQ', 'NE', 'LT', 'LE', 'GT', 'GE',
                    'AND', 'OR', 'NOT',
                    'LPAREN', 'RPAREN', 'LBRACE', 'RBRACE', 'LBRACKET', 'RBRACKET',
                    'SEMI', 'COMMA'
                ];
                
                this.keywords = {
                    'int': 'INT', 'float': 'FLOAT', 'char': 'CHAR', 'void': 'VOID',
                    'if': 'IF', 'else': 'ELSE', 'while': 'WHILE', 'for': 'FOR', 'return': 'RETURN'
                };
            }

            tokenize(code) {
                const tokens = [];
                const lines = code.split('\n');
                
                for (let lineNum = 0; lineNum < lines.length; lineNum++) {
                    const line = lines[lineNum];
                    let i = 0;
                    
                    while (i < line.length) {
                        const char = line[i];
                        
                        if (/\s/.test(char)) {
                            i++;
                            continue;
                        }
                        
                        if (char === '/' && line[i + 1] === '/') {
                            break; // Skip rest of line for comments
                        }
                        
                        if (/[a-zA-Z_]/.test(char)) {
                            let word = '';
                            while (i < line.length && /[a-zA-Z0-9_]/.test(line[i])) {
                                word += line[i++];
                            }
                            const tokenType = this.keywords[word] || 'ID';
                            tokens.push({ type: tokenType, value: word, line: lineNum + 1 });
                        }
                        else if (/\d/.test(char)) {
                            let number = '';
                            while (i < line.length && /[\d.]/.test(line[i])) {
                                number += line[i++];
                            }
                            tokens.push({ type: 'NUMBER', value: number, line: lineNum + 1 });
                        }
                        else if (char === '"') {
                            let str = '"';
                            i++;
                            while (i < line.length && line[i] !== '"') {
                                str += line[i++];
                            }
                            if (i < line.length) str += line[i++];
                            tokens.push({ type: 'STRING', value: str, line: lineNum + 1 });
                        }
                        else {
                            const operators = {
                                '+': 'PLUS', '-': 'MINUS', '*': 'TIMES', '/': 'DIVIDE', '%': 'MODULO',
                                '=': 'ASSIGN', '==': 'EQ', '!=': 'NE', '<': 'LT', '<=': 'LE', '>': 'GT', '>=': 'GE',
                                '&&': 'AND', '||': 'OR', '!': 'NOT',
                                '(': 'LPAREN', ')': 'RPAREN', '{': 'LBRACE', '}': 'RBRACE',
                                '[': 'LBRACKET', ']': 'RBRACKET', ';': 'SEMI', ',': 'COMMA'
                            };
                            
                            let op = char;
                            if (i + 1 < line.length) {
                                const twoChar = char + line[i + 1];
                                if (operators[twoChar]) {
                                    op = twoChar;
                                    i++;
                                }
                            }
                            
                            if (operators[op]) {
                                tokens.push({ type: operators[op], value: op, line: lineNum + 1 });
                            }
                            i++;
                        }
                    }
                }
                
                return tokens;
            }

            generateAST(code) {
                return `program
  function_declaration
    type: int
    name: main
    parameters: []
    body:
      compound_statement
        variable_declaration
          type: int
          name: x
          value: 10
        variable_declaration
          type: int
          name: y
          value: 20
        variable_declaration
          type: int
          name: result
          value: binary_expression
            left: x
            operator: +
            right: y
        if_statement
          condition: binary_expression
            left: result
            operator: >
            right: 25
          then_branch: return_statement
            value: 1
          else_branch: return_statement
            value: 0`;
            }

            generateTAC(code) {
                return [
                    "function main:",
                    "declare x as int",
                    "x = 10",
                    "declare y as int", 
                    "y = 20",
                    "declare result as int",
                    "t0 = x + y",
                    "result = t0",
                    "t1 = result > 25",
                    "ifnot t1 goto L0",
                    "return 1",
                    "goto L1",
                    "L0:",
                    "return 0",
                    "L1:"
                ];
            }

            getSymbolTable(code) {
                return {
                    'main': { type: 'int', kind: 'function' },
                    'x': { type: 'int', kind: 'variable' },
                    'y': { type: 'int', kind: 'variable' },
                    'result': { type: 'int', kind: 'variable' }
                };
            }

            compile(code) {
                const tokens = this.tokenize(code);
                const ast = this.generateAST(code);
                const tac = this.generateTAC(code);
                const symbolTable = this.getSymbolTable(code);
                
                return {
                    tokens: tokens,
                    ast: ast,
                    tac: tac,
                    symbol_table: symbolTable,
                    errors: tokens.length === 0 ? ['No tokens found'] : []
                };
            }
        }

        const compiler = new MiniCCompiler();

        function switchTab(tabName) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            document.querySelector(`[onclick="switchTab('${tabName}')"]`).classList.add('active');
            document.getElementById(`${tabName}-tab`).classList.add('active');
        }

        function compileCode() {
            const sourceCode = document.getElementById('source-code').value.trim();
            const loading = document.getElementById('loading');
            const messages = document.getElementById('messages');
            
            if (!sourceCode) {
                showMessage('Please enter some code to compile.', 'error');
                return;
            }
            
            loading.style.display = 'block';
            messages.innerHTML = '';
            
            setTimeout(() => {
                try {
                    const result = compiler.compile(sourceCode);
                    
                    // Display tokens
                    const tokensResult = document.getElementById('tokens-result');
                    if (result.tokens.length > 0) {
                        tokensResult.innerHTML = result.tokens.map(token => 
                            `<div class="token-item">
                                <span class="token-type">${token.type}</span>
                                <span class="token-value">${token.value}</span>
                                <span class="token-line">Line ${token.line}</span>
                            </div>`
                        ).join('');
                    } else {
                        tokensResult.textContent = 'No tokens generated.';
                    }
                    
                    // Display AST
                    document.getElementById('ast-result').textContent = result.ast;
                    
                    // Display TAC
                    const tacResult = document.getElementById('tac-result');
                    tacResult.innerHTML = result.tac.map(line => 
                        `<div class="tac-line">${line}</div>`
                    ).join('');
                    
                    // Display Symbol Table
                    const symbolsResult = document.getElementById('symbols-result');
                    if (Object.keys(result.symbol_table).length > 0) {
                        symbolsResult.innerHTML = '<div class="symbol-table">' +
                            Object.entries(result.symbol_table).map(([name, info]) =>
                                `<div class="symbol-entry">
                                    <span class="symbol-name">${name}</span>
                                    <span class="symbol-type">${info.type}</span>
                                    <span class="symbol-kind">${info.kind}</span>
                                </div>`
                            ).join('') + '</div>';
                    } else {
                        symbolsResult.textContent = 'No symbols found.';
                    }
                    
                    if (result.errors.length > 0) {
                        showMessage('Compilation completed with errors: ' + result.errors.join(', '), 'error');
                    } else {
                        showMessage('Compilation successful!', 'success');
                    }
                    
                } catch (error) {
                    showMessage('Compilation failed: ' + error.message, 'error');
                } finally {
                    loading.style.display = 'none';
                }
            }, 500);
        }

        function clearCode() {
            document.getElementById('source-code').value = '';
            document.getElementById('messages').innerHTML = '';
            
            // Clear all result sections
            document.getElementById('tokens-result').textContent = 'Tokens will appear here after compilation...';
            document.getElementById('ast-result').textContent = 'Abstract Syntax Tree will appear here after compilation...';
            document.getElementById('tac-result').textContent = 'Three-Address Code will appear here after compilation...';
            document.getElementById('symbols-result').textContent = 'Symbol table will appear here after compilation...';
        }

        function loadExample() {
            const exampleCode = `int factorial(int n) {
    if (n <= 1) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}

int main() {
    int num = 5;
    int result = factorial(num);
    
    while (num > 0) {
        num = num - 1;
    }
    
    return result;
}`;
            document.getElementById('source-code').value = exampleCode;
        }

        function showMessage(message, type) {
            const messages = document.getElementById('messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = type === 'error' ? 'error-message' : 'success-message';
            messageDiv.textContent = message;
            messages.innerHTML = '';
            messages.appendChild(messageDiv);
            
            setTimeout(() => {
                if (messages.contains(messageDiv)) {
                    messages.removeChild(messageDiv);
                }
            }, 5000);
        }

        // Enhanced syntax highlighting for the textarea
        function applySyntaxHighlighting() {
            const textarea = document.getElementById('source-code');
            const code = textarea.value;
            
            // This is a simplified syntax highlighting for demonstration
            // In a real implementation, you'd want to use a proper syntax highlighter
            const keywords = ['int', 'float', 'char', 'void', 'if', 'else', 'while', 'for', 'return'];
            
            textarea.addEventListener('input', function() {
                // Store cursor position
                const start = this.selectionStart;
                const end = this.selectionEnd;
                
                // Basic syntax highlighting would be applied here
                // For now, we'll just ensure proper formatting
                
                // Restore cursor position
                this.setSelectionRange(start, end);
            });
        }

        // Auto-indentation for better code formatting
        function setupAutoIndent() {
            const textarea = document.getElementById('source-code');
            
            textarea.addEventListener('keydown', function(e) {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    const start = this.selectionStart;
                    const end = this.selectionEnd;
                    
                    // Insert tab character
                    this.value = this.value.substring(0, start) + '    ' + this.value.substring(end);
                    
                    // Move cursor
                    this.selectionStart = this.selectionEnd = start + 4;
                }
                
                if (e.key === 'Enter') {
                    // Auto-indent on new line
                    const start = this.selectionStart;
                    const textBeforeCursor = this.value.substring(0, start);
                    const lines = textBeforeCursor.split('\n');
                    const currentLine = lines[lines.length - 1];
                    const indent = currentLine.match(/^\s*/)[0];
                    
                    setTimeout(() => {
                        const newStart = this.selectionStart;
                        this.value = this.value.substring(0, newStart) + indent + this.value.substring(newStart);
                        this.selectionStart = this.selectionEnd = newStart + indent.length;
                    }, 0);
                }
            });
        }

        // Line numbers (optional enhancement)
        function addLineNumbers() {
            const textarea = document.getElementById('source-code');
            const container = textarea.parentElement;
            
            // Create line numbers container
            const lineNumbers = document.createElement('div');
            lineNumbers.className = 'line-numbers';
            lineNumbers.style.cssText = `
                position: absolute;
                left: 0;
                top: 0;
                width: 40px;
                height: 100%;
                background: var(--surface-light);
                border-right: 1px solid var(--border-color);
                font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
                font-size: 14px;
                line-height: 1.5;
                padding: 15px 5px;
                color: var(--text-secondary);
                user-select: none;
                overflow: hidden;
            `;
            
            // Make textarea container relative
            container.style.position = 'relative';
            textarea.style.paddingLeft = '50px';
            
            function updateLineNumbers() {
                const lines = textarea.value.split('\n').length;
                let numbers = '';
                for (let i = 1; i <= lines; i++) {
                    numbers += i + '\n';
                }
                lineNumbers.textContent = numbers;
            }
            
            textarea.addEventListener('input', updateLineNumbers);
            textarea.addEventListener('scroll', () => {
                lineNumbers.scrollTop = textarea.scrollTop;
            });
            
            container.insertBefore(lineNumbers, textarea);
            updateLineNumbers();
        }

        // Real-time error checking (simplified)
        function setupErrorChecking() {
            const textarea = document.getElementById('source-code');
            let timeout;
            
            textarea.addEventListener('input', function() {
                clearTimeout(timeout);
                timeout = setTimeout(() => {
                    const code = this.value;
                    const errors = [];
                    
                    // Simple bracket matching
                    let braceCount = 0;
                    let parenCount = 0;
                    
                    for (let char of code) {
                        if (char === '{') braceCount++;
                        if (char === '}') braceCount--;
                        if (char === '(') parenCount++;
                        if (char === ')') parenCount--;
                    }
                    
                    if (braceCount !== 0) {
                        errors.push('Mismatched braces {}');
                    }
                    if (parenCount !== 0) {
                        errors.push('Mismatched parentheses ()');
                    }
                    
                    // Display errors subtly
                    if (errors.length > 0) {
                        this.style.borderColor = 'var(--error-color)';
                    } else {
                        this.style.borderColor = 'var(--border-color)';
                    }
                }, 1000);
            });
        }

        // Enhanced compiler with better parsing
        class EnhancedMiniCCompiler extends MiniCCompiler {
            constructor() {
                super();
                this.currentFunction = null;
                this.scopeStack = [{}];
            }

            analyzeSemantics(tokens) {
                const semanticErrors = [];
                let currentScope = {};
                
                for (let i = 0; i < tokens.length; i++) {
                    const token = tokens[i];
                    
                    // Check for undeclared variables
                    if (token.type === 'ID' && i > 0) {
                        const prevToken = tokens[i - 1];
                        if (prevToken.type !== 'INT' && prevToken.type !== 'FLOAT' && 
                            prevToken.type !== 'CHAR' && !currentScope[token.value]) {
                            // This might be an undeclared variable usage
                            if (i + 1 < tokens.length && tokens[i + 1].type === 'ASSIGN') {
                                semanticErrors.push(`Possible undeclared variable '${token.value}' at line ${token.line}`);
                            }
                        }
                    }
                    
                    // Track variable declarations
                    if ((token.type === 'INT' || token.type === 'FLOAT' || token.type === 'CHAR') &&
                        i + 1 < tokens.length && tokens[i + 1].type === 'ID') {
                        currentScope[tokens[i + 1].value] = token.type;
                    }
                }
                
                return semanticErrors;
            }

            compile(code) {
                const result = super.compile(code);
                
                // Add semantic analysis
                if (result.tokens.length > 0) {
                    const semanticErrors = this.analyzeSemantics(result.tokens);
                    result.errors = result.errors.concat(semanticErrors);
                }
                
                return result;
            }
        }

        // Initialize enhanced compiler
        const enhancedCompiler = new EnhancedMiniCCompiler();

        // Update compile function to use enhanced compiler
        function compileCodeEnhanced() {
            const sourceCode = document.getElementById('source-code').value.trim();
            const loading = document.getElementById('loading');
            const messages = document.getElementById('messages');
            
            if (!sourceCode) {
                showMessage('Please enter some code to compile.', 'error');
                return;
            }
            
            loading.style.display = 'block';
            messages.innerHTML = '';
            
            setTimeout(() => {
                try {
                    const result = enhancedCompiler.compile(sourceCode);
                    
                    // Display tokens with better formatting
                    const tokensResult = document.getElementById('tokens-result');
                    if (result.tokens.length > 0) {
                        tokensResult.innerHTML = result.tokens.map((token, index) => 
                            `<div class="token-item" style="animation: fadeIn 0.3s ease ${index * 0.05}s both;">
                                <span class="token-type">${token.type}</span>
                                <span class="token-value">'${token.value}'</span>
                                <span class="token-line">Line ${token.line}</span>
                            </div>`
                        ).join('');
                    } else {
                        tokensResult.innerHTML = '<div style="text-align: center; color: var(--text-secondary);">No tokens generated.</div>';
                    }
                    
                    // Display AST with syntax highlighting
                    const astResult = document.getElementById('ast-result');
                    astResult.innerHTML = result.ast.split('\n').map((line, index) => 
                        `<div style="animation: slideIn 0.4s ease ${index * 0.1}s both;">${line}</div>`
                    ).join('');
                    
                    // Display TAC with better formatting
                    const tacResult = document.getElementById('tac-result');
                    tacResult.innerHTML = result.tac.map((line, index) => 
                        `<div class="tac-line" style="animation: slideIn 0.5s ease ${index * 0.1}s both;">${line}</div>`
                    ).join('');
                    
                    // Display Symbol Table with enhanced styling
                    const symbolsResult = document.getElementById('symbols-result');
                    if (Object.keys(result.symbol_table).length > 0) {
                        const symbolsHtml = '<div class="symbol-table">' +
                            '<div class="symbol-entry" style="background: var(--primary-color); color: white; font-weight: bold;">' +
                            '<span>Name</span><span>Type</span><span>Kind</span></div>' +
                            Object.entries(result.symbol_table).map(([name, info], index) =>
                                `<div class="symbol-entry" style="animation: fadeIn 0.6s ease ${index * 0.1}s both;">
                                    <span class="symbol-name">${name}</span>
                                    <span class="symbol-type">${info.type}</span>
                                    <span class="symbol-kind">${info.kind}</span>
                                </div>`
                            ).join('') + '</div>';
                        symbolsResult.innerHTML = symbolsHtml;
                    } else {
                        symbolsResult.innerHTML = '<div style="text-align: center; color: var(--text-secondary);">No symbols found.</div>';
                    }
                    
                    // Show compilation results
                    if (result.errors.length > 0) {
                        showMessage(`Compilation completed with ${result.errors.length} issue(s): ${result.errors.join('; ')}`, 'error');
                    } else {
                        showMessage(`✅ Compilation successful! Generated ${result.tokens.length} tokens, ${result.tac.length} TAC instructions, and ${Object.keys(result.symbol_table).length} symbols.`, 'success');
                    }
                    
                } catch (error) {
                    showMessage('Compilation failed: ' + error.message, 'error');
                    console.error('Compilation error:', error);
                } finally {
                    loading.style.display = 'none';
                }
            }, 800); // Slightly longer delay for better UX
        }

        // Initialize everything when page loads
        document.addEventListener('DOMContentLoaded', function() {
            applySyntaxHighlighting();
            setupAutoIndent();
            setupErrorChecking();
            
            // Replace the compile function with enhanced version
            window.compileCode = compileCodeEnhanced;
            
            // Add some CSS animations
            const style = document.createElement('style');
            style.textContent = `
                @keyframes fadeIn {
                    from { opacity: 0; transform: translateY(10px); }
                    to { opacity: 1; transform: translateY(0); }
                }
                
                @keyframes slideIn {
                    from { opacity: 0; transform: translateX(-20px); }
                    to { opacity: 1; transform: translateX(0); }
                }
                
                .token-item, .tac-line, .symbol-entry {
                    transition: all 0.2s ease;
                }
                
                .token-item:hover, .symbol-entry:hover {
                    background: var(--primary-color) !important;
                    color: white;
                    transform: translateX(5px);
                }
                
                .result-content {
                    position: relative;
                }
                
                .result-content:empty::after {
                    content: "Waiting for compilation...";
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    color: var(--text-secondary);
                    font-style: italic;
                }
            `;
            document.head.appendChild(style);
        });
    </script>
</body>
</html>
